## NIO

BIO ：

在使用同步I/O（BIO）的网络应用中，如果要同时处理多个客户端请求，或是在客户端要同时和多个服务器进行通讯，就必须使用多线程来处理，即一个连接一个线程，当请求数过多会造成服务器压力过大。

NIO：

一个有效的请求一个线程

 NIO的最重要的地方是当一个连接创建后，不需要对应一个线程，这个连接会被注册到多路复用器上面，所以所有的连接只需要一个线程就可以搞定，当这个线程中的多路复用器进行轮询的时候，发现连接上有请求的话，才开启一个线程进行处理，也就是一个请求一个线程模式。

BIO：调用accept方法后会阻塞，等待连接结束，此时我们可以通过多线程来解决阻塞问题，但是多线程也带来两个问题：1.多线程会占用系统资源2.线程间切换成本很高，利用线程池（伪异步模型）可以解决1的问题，但是还是无法从根本上解决BIO的问题（每个连接一个线程），当并发量不高时，采用该种方式可以考虑，但是当并发量较大时，我们需要一个更加高效的I/O处理模型。

NIO实现原理：服务器上所有Channel需要向Selector注册，而Selector则负责监视这些Socket的IO状态(观察者)，当其中任意一个或者多个Channel具有可用的IO操作时，该Selector的select()方法将会返回大于0的整数，该整数值就表示该Selector上有多少个Channel具有可用的IO操作，并提供了selectedKeys（）方法来返回这些Channel对应的SelectionKey集合(一个SelectionKey对应一个就绪的通道)。正是通过Selector，使得服务器端只需要不断地调用Selector实例的select()方法即可知道当前所有Channel是否有需要处理的IO操作。注：java NIO就是多路复用IO，jdk7之后底层是epoll模型。

BIO面向流

NIO面向缓冲区



https://www.cnblogs.com/crazymakercircle/p/10225159.html

同步异步

同步：我们自己检查结果

异步：操作系统通知我们操作结果

https://tech.meituan.com/2016/11/04/nio.html