## 深入理解jvm（周志明）

1.运行时内存划分

- 程序计数器(PC寄存器)
  - 线程私有
  - 指向当前线程正在执行的字节码的地址和行号，如果是Native方法，则为空(Undefined)
  - 唯一一个没有OutOfMemoryError的内存区域

- 虚拟机栈
  - 线程私有
  - 栈帧：用于存储局部变量表、操作数栈、动态连接、方法出口等信息。每个方法被调用到执行完毕的过程，对应着一个栈帧从入栈到出栈的过程
    - 局部变量表
      - 基本数据类型
      - 引用类型
      - returnAddress类型
    - 在局部变量表中，数据以局部变量槽来表示（Slot），其中64位的long和double会占用两个Slot，其余的只占用一个。局部变量表所需的内存空间在编译期间完成分配，当进入一个方法是，这个方法需要在栈帧中分配多大的局部变量空间是完全确定的，在方法运行期间不会改变局部变量表的大小。
  - 异常
    - StackOverflowError：当栈深度溢出
    - OutOfMemoryError：当无法申请到足够的内存

- 本地方法栈
  - 与虚拟机栈一样，只是虚拟机栈为java方法服务，本地方法栈为Native方法服务
  - 异常：与虚拟机栈一致

- java堆

  - 线程共享
  - 作用：唯一的作用就是存放对象实例
  - 多数虚拟机都支持java堆可扩展(即-Xmx 和-Xms设定)
  - 异常
    - OutOfMemoryError：当堆无法扩展时

- 方法区

  - 共享内存
  - 用于存储虚拟机加载的类型信息、常量、静态变量、即时编译器编译后的代码缓存等数据
  - 异常
    - OutOfMemoryError：当方法区无法满足新的内存分配需求是

  - 运行时常量池
    - 类的版本
    - 字段
    - 方法
    - 接口等描述信息

2.OutOfMemoryError异常

- java堆异常
  - 通过-Xms 和-Xmx设置最小值和最大值
    - 通过将-Xms和-Xmx设置为相同大小，即可设置java堆内存不可扩展
  - -XX:+HeapDumpOnOutOfMemoryError：设置在出现内存溢出时Dump出当前的内存堆转储快照
    - java.lang.OutOfMemoryError: Java heap space
      Dumping heap to java_pid4944.hprof ...
      Heap dump file created [28283880 bytes in 0.071 secs]
  - Exception in thread "main" java.lang.OutOfMemoryError: Java heap space
    - 解决：
      - 1.通过内存影响分析工具对Dump出来的堆转储快照进行分析
      - 2.确认内存中导致OOM的对象是否是必要的，也就是区分到底是内存泄露（Memory Leak）还是内存溢出（Memory Overflow）
        - 如果是内存泄露：可通过工具查看泄露对象到GC Roots的引用链，找到泄露对象是通过怎样的应用途径、与那些GC Roots相关联，才导致垃圾收集器无法回收他们，根据泄露对象的类型信息以及它到GC Roots引用链的信息，一般可以比较准确地定位到这些对象创建爱你的位置，进而找到产生内存泄漏的代码的具体位置
        - 如果不是内存泄露，换句话说就是内存中的对象

- 虚拟机栈和本地方法栈异常

  - HotSpot不区分虚拟机栈和本地方法栈，所以对于HotSpot来说，-Xoss参数（设置本地方法栈大小）虽然存在，但实际上是没有效果的，栈容量只能由

    -Xss参数来设定。

  - 虚拟机规范中描述了两种异常

    - 如果线程请求的栈深度大于虚拟机所允许的最大深度，将抛出StackOverflowError异常
    - 如果虚拟机的栈内存允许动态扩展，当扩展栈容量无法申请到足够的内存时，将抛出OutOfMemoryError

  - java虚拟机规范那种明确允许java虚拟机实现自行选择是否支持栈的动态扩展，而HotSpot虚拟机的选择是不支持扩展，所以除非在创建线程申请内存时就因为无法获得足够内存而出现OutOfMemoryError异常，否则在线程运行时是不会因为扩展而导致内存溢出的

  - 引发异常的方式

    - 使用-Xss参数减少占内存容量
    - 定义大量的本地变量，增大此方法帧中本地变量表的长度

  - 无论是由于栈帧太大还是虚拟机容量太小，当新的栈帧内存无法分配的时候，HotSpot虚拟机抛出的都是StackOverflow异常。但是对于方式2，在Classic虚拟机中会得到OutOfMemoryError异常。

  - HotSpot也会得到OutOfMemoryError，前提是多线程情况下，每个线程分配到的占内存越大，可以建立的线程数量自然就越少，建立线程时就越容易把剩下的内存耗尽，如果生产中出现这样的情况，在不能减少线程数量或者更换64位虚拟机的情况下，可以通过减少最大堆和减少栈容量来换取更多的线程来避免异常产生。

























































